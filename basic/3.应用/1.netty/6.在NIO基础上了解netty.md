## 原生NIO的问题

* NIO类库和API繁杂
* 要写出高质量的NIO程序，需要熟悉Java多线程编程，Reactor模式，网络编程
* 开发工作量和难度大：客户端重连，网络闪断，半包读写，失败缓存，网络拥塞，异常流处理
* JDK1.7仍然存在selector空轮询的BUG

## Netty优点

* Netty对JDK自带的NIO的API进行了封装
* 设计优雅：适用于各种传输类型的统一API阻塞和费阻塞Socket，基于灵活且可扩展的事件模型，可以清晰的分离关注点，高度可定制的线程模型->单线程，一个或多个线程池
* 高性能，吞吐量高，延迟更低，减少资源消耗，最小化不必要的内存复制
* 安全：完整的SSL/TLS和StartTLS支持

> 当前使用的是Netty4.x稳定版本

## Netty的高性能架构

### 线程模型基本介绍

* 目前存在的线程模型
  * 传统阻塞I/O服务模型
  * Reactor模式
* 根据Reactor的数目和处理资源池线程的数量不同，有三种典型的表现
  * 单Reactor 单线程
  * 单Reactor 多线程
  * 主从Reactor 多线程
* Netty主要基于主从Reactor多线程模型做了一定的改进，其中主从Reactor有多个Reactor

### 线程模型对比

#### 传统阻塞IO模型

* 每个连接都需要独立的线程完成数据的输入，业务处理，数据返回
* 当并发很大的时候，会创建大量的线程，占用很大的系统资源
* 当连接创建成功，当前线程没有数据可读，该线程会一直阻塞到read操作，造成资源浪费

![image-20210524174216046](https://gitee.com/BothSavage/PicGo/raw/master//image/20210524174216.png)

#### Reactor模式

##### 介绍

* 基于IO复用模型，多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象等待，无需阻塞等待所有的连接，当某个连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理。Reactor又叫反应器模式，分发者模式（dispatcher），通知者模式（notifier）
* 基于线程池复用线程资源，不必为了每个连接创建线程，将连接完成后的业务处理分配给其它线程进行处理，一个线程可以处理多个连接的业务
* 通过一个或者多个输入同时输入给服务处理器，基于事件驱动
* 服务器处理传入的多个请求，并将他们同步分配到相应的处理线程，相当于分发器
* 采用IO复用监听，收到事件后，分发给某个线程，这点就是网络服务器高并发处理的关键

![image-20210524180143825](https://gitee.com/BothSavage/PicGo/raw/master//image/20210524180143.png)

##### 核心组成

* reactor
  * 在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对IO事件做出反应
  * 就像是公司的电话接线员，接听来自客户的电话并转接到合适的联系人
* Handler
  * 处理程序执行IO事件要完成的实际事件



## 引用

1.[尚硅谷_韩顺平_Netty核心技术及源码剖析](http://www.atguigu.com/)

