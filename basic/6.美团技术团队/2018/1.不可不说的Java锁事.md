## 零：来源

文章地址：[不可不说的Java锁事](https://tech.meituan.com/2018/11/15/java-lock.html)

作者：家琪 美团技术团队(wx号：meituantech)

时间：2018年11月15日

完成时间：

## 壹：前言

Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。本文旨在对锁相关源码（本文中的源码来自JDK 8和Netty 3.10.6）、使用场景进行举例，为读者介绍主流锁的知识点，以及不同的锁的适用场景。

Java中往往是按照是否含有某一特性来定义锁，我们通过特性将锁进行分组归类，再使用对比的方式进行介绍，帮助大家更快捷的理解相关知识。下面给出本文内容的总体分类目录：







![img](https://gitee.com/BothSavage/PicGo/raw/master//image/7f749fc8.png)



> * Java主流锁
>   * 线程要不要锁住同步资源
>     * 悲观锁
>       * 锁住
>     * 乐观锁
>       * 不锁
>   * 锁住同步资源失败，要不要阻塞
>     * 阻塞
>     * 不阻塞
>       * 自旋锁
>       * 适应性自旋锁
>   * 多个线程竞争同步资源的流程细节有没有区别
>     * 无锁
>       * 不锁资源，多个线程只有一个能修改资源成功，其他线程会重试
>     * 偏向锁
>       * 同一个线程执行同步资源时自动获取资源
>     * 轻量级锁
>       * 多个线程竞争同步资源时，没有获取资源的线程**自旋**等待锁释放
>     * 重量级锁
>       * 多个资源竞争同步资源时，没有获取资源的线程阻塞并等待被唤醒
>   * 多个线程竞争时要不要排队
>     * 排队
>       * 公平锁
>     * 先插队，插队失败再排队
>       * 非公平锁
>   * 一个线程中的多个流程能不能获取到同一把锁
>     * 能、
>       * 可重入锁
>     * 不能
>       * 非重入锁
>   * 多个线程能不能共享一把锁
>     * 共享锁
>     * 排他锁

## 贰：乐观锁VS悲观锁

乐观锁和悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库都有此概念的实际运用

先说概念。对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被其他线程修改。Java中Synchronized关键字和Lock的实现都是悲观锁。

而乐观锁认为自己在使用数据的时候，不会有别的线程来修改，所以不添加锁，只是在更新数据到时候去判断之前的有没有线程更新了这个数据，如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程跟更新，则根据不同的实现方式执行不同的操作（**保存和自动重试**）

>乐观锁可以自动重试的

乐观锁在Java中是通过无锁编程来实现的，最常用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的

![img](https://gitee.com/BothSavage/PicGo/raw/master//image/c8703cd9.png)

## 叁：标题3

## 肆：标题4

## 伍：标题5

## 陆：标题6

## 柒：标题7

