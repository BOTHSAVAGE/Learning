## 零：来源

文章地址：[Java线程池实现原理及其在美团业务中的实践](https://mp.weixin.qq.com/s/baYuX8aCwQ9PP6k7TDl2Ww)

作者：致远 陆晨 美团技术团队(wx号：meituantech)

时间：2020-04-02

## 壹：写在前面

### 1.1线程池是什么

线程池（Thread Pool）是一种基于池化思想管理，经常出现在多线程的服务器，比如MySQL

线程过多会带来额外的开销，其中包括创建销毁线程的开销，调度线程的开销等等，同时也减低了计算机的整体性能。线程池维护多个线程，等待监督管理者分配可并发执行的任务，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。

而本文描述线程池是JDK中提供的ThreadPoolExecutor类。

当然，使用线程池可以带来一系列好处：

- **降低资源消耗**：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。
- **提高响应速度**：任务到达时，无需等待线程创建即可立即执行。
- **提高线程的可管理性**：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。
- **提供更多更强大的功能**：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。

### 1.2线程池解决的问题是什么

线程池解决的核心问题就是资源管理问题。在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入。这种不确定性将带来以下若干问题：

1. 频繁申请/销毁资源和调度资源，将带来额外的消耗，可能会非常巨大。
2. 对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。
3. 系统无法合理管理内部的资源分布，会降低系统的稳定性。

> 为解决资源分配的问题，线程采用池化的思想，为了最大化收益并最小化风险，将资源统一在一起管理的思想

“池化”思想不仅仅能应用在计算机领域，在金融、设备、人员管理、工作管理等领域也有相关的应用。

在计算机领域中的表现为：统一管理IT资源，包括服务器、存储、和网络资源等等。通过共享资源，使用户在低投入中获益。除去线程池，还有其他比较典型的几种使用策略包括：

* 内存池：预先申请内存，提升申请内存速度，减小内存碎皮
* 连接池：预先申请数据库连接，提升申请连接的速度，降低系统的开销
* 实例池：循环使用对象，减小资源在初始化和释放时的昂贵资源

## 贰：线程池核心设计与实现

在前文中，我们了解到：线程池是一种通过“池化”思想，帮助我们管理线程而获取并发性的工具，在Java中的体现是ThreadPoolExecutor类

### 2.1总体设计

Java中的线程池核心实现类是ThreadPoolExecutor，本章基于JDK 1.8的源码来分析Java线程池的核心设计与实现。我们首先来看一下ThreadPoolExecutor的UML类图，了解下ThreadPoolExecutor的继承关系。

![image-20210608165101196](C:\Users\y\AppData\Roaming\Typora\typora-user-images\image-20210608165101196.png)

ThreadPoolExecutor实现的顶层接口是Executor，顶层接口Executor提供了一种思想：**将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需要提供runnable对象，将任务的运行逻辑提交到执行器(executor)中，由执行器完成线程的调配和任务的执行部分**ExecutorService接口增加了一些能力：

（1）扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法

（2）提供管控线程池的方法，比如停止线程池的运行

AbstractExecutorService则是上层的抽象类，将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。最下层的实现类ThreadPoolExecutor实现最复杂的运行部分，ThreadPoolExecutor将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。



ThreadPoolExecutor的运行，同时维护线程和执行任务的运行机制如下

![image-20210608171054361](C:\Users\y\AppData\Roaming\Typora\typora-user-images\image-20210608171054361.png)

线程池在内部实际上构建了一个生产者消费者模型，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。线程池的运行主要分成两部分：任务管理，线程管理。任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的流转

* 直接申请线程执行任务
* 缓冲到队列中等待线程执行
* 拒绝该任务

线程管理部分是消费者，他们被统一的维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会获取新的任务去执行，最后当线程获取不到任务的时候，线程就会被回收

接下来按照三个部分

* 线程池如何维护自身状态
* 线程池如何管理任务
* 线程池如何去管理线程

### 2.2生命周期管理

线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行，由内部来维护。线程池内部使用一个变量维护两个值：运行状态(runState)和线程数量 (workerCount)。在具体实现中，线程池将运行状态(runState)、线程数量 (workerCount)两个关键参数的维护放在了一起，如下代码所示：

```java
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
```

ct1这个AtomicInteger类型，是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段，它同时包含两部分的信息：线程池的运行的状态(runState)和线程池内有效线程的数量(workerCount)，高3位保存runState，低29位保存workerCount，两个变量之间互不干扰。用一个变量去存储两个值。可以避免在做相关决策的时候，出现不一致的情况，而占用锁资源。因为通过阅读线程池源代码可以发现，经常出现要同时判断线程池运行状态和线程数量的情况，线程池也提供了若干方法去供用户获取线程池当前的运行状态，线程个数。这里都是用的是位运算，相比较基本运算会快很多。

关于内部封装的获取生命周期状态、获取线程池线程数量的计算方法如以下代码所示：

```java
private static int runStateOf(int c)     { return c & ~CAPACITY; } //计算当前运行状态
private static int workerCountOf(int c)  { return c & CAPACITY; }  //计算当前线程数量
private static int ctlOf(int rs, int wc) { return rs | wc; }   //通过状态和线程数生成ctl
```

ThreadPoolExecutor的运行状态有5种，分别为：

* RUNNING
  * 能接收新提交的任务，并且也能处理阻塞队列中的任务
* SHUTDOWN
  * 关闭状态，不能接受新提交的任务，但却可以继续处理阻塞队列里面已经保存的任务
* STOP
  * 不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程
* TIDYING
  * 所有任务都终止了，workerCount(有效线程)为0
* TERMINATED
  * 在terminated方法执行完成后进入该状态



线程池生命周期的转换如下所示

![image-20210608174053759](C:\Users\y\AppData\Roaming\Typora\typora-user-images\image-20210608174053759.png)

### 2.3任务执行机制

#### 2.3.1任务调度

任务调度是线程池的主要入口，当用户提交了一个任务，接下来这个任务将如何执行都是有这个阶段来决定的。**任务调度是线程池的核心运行机制**

所有任务的调度都是由execute方法完成的，这部分的工作是：检查现在线程池的运行状态，运行线程数，运行策略，决定接下来的执行流程，是直接申请线程执行，或是缓冲到队列中执行，或是拒绝，过程如下：

* 检查线程池的运行状态，如果不是running直接拒绝，线程池要保证在RUNNING的状态下执行任务。
* 如果workerCount < corePoolSize，则创建并启动一个线程来执行新提交的任务
* 如果workerCount >= corePoolSize，且线程池的阻塞队列未满，则将任务添加到该阻塞队列中
* 如果workerCount >= corePoolSize && workerCount < maximumPoolSize ，并且线程池阻塞队列已满，则创建并启动一个线程来执行新提交的任务
* 如果workerCount >= maximumPoolSize，并且线程池阻塞队列已满，则根据拒绝策略来处理该任务，默认的处理方式是直接抛异常

任务调度流程如下：

![image-20210608174943039](C:\Users\y\AppData\Roaming\Typora\typora-user-images\image-20210608174943039.png)

> 开始提交任务，如果线程池不是在跑直接拒绝。如果在运行，判断线程池和核心数，如果还没打满核心数，直接new一个线程开始干，如果满了，那么看阻塞队列是否被打满了，如果阻塞队列还有剩余，那就送任务去排队，如果队伍也满了，看看到了线程池的极限线程数没有，如果没有到，那么new一个，如果到了直接使用拒绝策略，默认就是抛出异常
>
> 判断逻辑是：核心数，当前线程数，队列数，最大线程数，线程池状态

#### 2.3.2任务缓冲

任务缓冲模块是线程池能够管理任务的核心部分。线程池的本质是对任务和线程的管理，而做到这一点最关键的思想就是将任务和线程两者解耦，不让两者直接关联，才可以做后续的分配工作。**线程池是以生产者消费者模式**，通过一个阻塞队列来实现的。阻塞队列缓存任务，工作线程从阻塞队列中获取任务

阻塞队列支持两个附加操作

* 当队列为空，获取元素的线程会等待队列变成非空。
* 当队列为满，存储元素的线程会等待队列可用

阻塞队列常常用于生产者和消费者的场景，生产者是往队列中添加元素的线程，消费者是从队列里面拿元素的线程，阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素

![image-20210608180202008](C:\Users\y\AppData\Roaming\Typora\typora-user-images\image-20210608180202008.png)

使用不同的队列可以实现不一样的任务存取策略，如下成员在不同的场景下才能发挥作用

* ArrayBlockingQueue 
  * 一个使用数组实现的有界阻塞队列，此队列按照先进先出的原则对元素进行排序，支持公平锁和非公平锁
* LinkedBlockingQueue
  * 链表结构组成的有界队列，FIFO进行排序，此队列的默认长度为Integer.Max_Value