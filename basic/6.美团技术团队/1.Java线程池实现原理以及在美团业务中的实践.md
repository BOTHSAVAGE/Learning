## 零：来源

文章地址：[Java线程池实现原理及其在美团业务中的实践](https://mp.weixin.qq.com/s/baYuX8aCwQ9PP6k7TDl2Ww)

作者：致远 陆晨 美团技术团队(wx号：meituantech)

时间：2020-04-02

完成时间：

## 壹：写在前面

### 1.1线程池是什么

线程池（Thread Pool）是一种基于池化思想管理，经常出现在多线程的服务器，比如MySQL

线程过多会带来额外的开销，其中包括创建销毁线程的开销，调度线程的开销等等，同时也减低了计算机的整体性能。线程池维护多个线程，等待监督管理者分配可并发执行的任务，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。

而本文描述线程池是JDK中提供的ThreadPoolExecutor类。

当然，使用线程池可以带来一系列好处：

- **降低资源消耗**：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。
- **提高响应速度**：任务到达时，无需等待线程创建即可立即执行。
- **提高线程的可管理性**：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。
- **提供更多更强大的功能**：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。

### 1.2线程池解决的问题是什么

线程池解决的核心问题就是资源管理问题。在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入。这种不确定性将带来以下若干问题：

1. 频繁申请/销毁资源和调度资源，将带来额外的消耗，可能会非常巨大。
2. 对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。
3. 系统无法合理管理内部的资源分布，会降低系统的稳定性。

> 为解决资源分配的问题，线程采用池化的思想，为了最大化收益并最小化风险，将资源统一在一起管理的思想

“池化”思想不仅仅能应用在计算机领域，在金融、设备、人员管理、工作管理等领域也有相关的应用。

在计算机领域中的表现为：统一管理IT资源，包括服务器、存储、和网络资源等等。通过共享资源，使用户在低投入中获益。除去线程池，还有其他比较典型的几种使用策略包括：

* 内存池：预先申请内存，提升申请内存速度，减小内存碎皮
* 连接池：预先申请数据库连接，提升申请连接的速度，降低系统的开销
* 实例池：循环使用对象，减小资源在初始化和释放时的昂贵资源

## 贰：线程池核心设计与实现

在前文中，我们了解到：线程池是一种通过“池化”思想，帮助我们管理线程而获取并发性的工具，在Java中的体现是ThreadPoolExecutor类

### 2.1总体设计

Java中的线程池核心实现类是ThreadPoolExecutor，本章基于JDK 1.8的源码来分析Java线程池的核心设计与实现。我们首先来看一下ThreadPoolExecutor的UML类图，了解下ThreadPoolExecutor的继承关系。

![image-20210608165101196](https://gitee.com/BothSavage/PicGo/raw/master//image/image-20210608165101196.png)

ThreadPoolExecutor实现的顶层接口是Executor，顶层接口Executor提供了一种思想：**将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需要提供runnable对象，将任务的运行逻辑提交到执行器(executor)中，由执行器完成线程的调配和任务的执行部分**ExecutorService接口增加了一些能力：

（1）扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法

（2）提供管控线程池的方法，比如停止线程池的运行

AbstractExecutorService则是上层的抽象类，将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。最下层的实现类ThreadPoolExecutor实现最复杂的运行部分，ThreadPoolExecutor将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。



ThreadPoolExecutor的运行，同时维护线程和执行任务的运行机制如下

![image-20210608171054361](https://gitee.com/BothSavage/PicGo/raw/master//image/image-20210608171054361.png)

线程池在内部实际上构建了一个生产者消费者模型，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。线程池的运行主要分成两部分：任务管理，线程管理。任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的流转

* 直接申请线程执行任务
* 缓冲到队列中等待线程执行
* 拒绝该任务

线程管理部分是消费者，他们被统一的维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会获取新的任务去执行，最后当线程获取不到任务的时候，线程就会被回收

接下来按照三个部分

* 线程池如何维护自身状态
* 线程池如何管理任务
* 线程池如何去管理线程

### 2.2生命周期管理

线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行，由内部来维护。线程池内部使用一个变量维护两个值：运行状态(runState)和线程数量 (workerCount)。在具体实现中，线程池将运行状态(runState)、线程数量 (workerCount)两个关键参数的维护放在了一起，如下代码所示：

```java
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
```

ct1这个AtomicInteger类型，是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段，它同时包含两部分的信息：线程池的运行的状态(runState)和线程池内有效线程的数量(workerCount)，高3位保存runState，低29位保存workerCount，两个变量之间互不干扰。用一个变量去存储两个值。可以避免在做相关决策的时候，出现不一致的情况，而占用锁资源。因为通过阅读线程池源代码可以发现，经常出现要同时判断线程池运行状态和线程数量的情况，线程池也提供了若干方法去供用户获取线程池当前的运行状态，线程个数。这里都是用的是位运算，相比较基本运算会快很多。

关于内部封装的获取生命周期状态、获取线程池线程数量的计算方法如以下代码所示：

```java
private static int runStateOf(int c)     { return c & ~CAPACITY; } //计算当前运行状态
private static int workerCountOf(int c)  { return c & CAPACITY; }  //计算当前线程数量
private static int ctlOf(int rs, int wc) { return rs | wc; }   //通过状态和线程数生成ctl
```

ThreadPoolExecutor的运行状态有5种，分别为：

* RUNNING
  * 能接收新提交的任务，并且也能处理阻塞队列中的任务
* SHUTDOWN
  * 关闭状态，不能接受新提交的任务，但却可以继续处理阻塞队列里面已经保存的任务
* STOP
  * 不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程
* TIDYING
  * 所有任务都终止了，workerCount(有效线程)为0
* TERMINATED
  * 在terminated方法执行完成后进入该状态



线程池生命周期的转换如下所示

![image-20210608174053759](https://gitee.com/BothSavage/PicGo/raw/master//image/image-20210608174053759.png)

### 2.3任务执行机制

#### 2.3.1任务调度

任务调度是线程池的主要入口，当用户提交了一个任务，接下来这个任务将如何执行都是有这个阶段来决定的。**任务调度是线程池的核心运行机制**

所有任务的调度都是由execute方法完成的，这部分的工作是：检查现在线程池的运行状态，运行线程数，运行策略，决定接下来的执行流程，是直接申请线程执行，或是缓冲到队列中执行，或是拒绝，过程如下：

* 检查线程池的运行状态，如果不是running直接拒绝，线程池要保证在RUNNING的状态下执行任务。
* 如果workerCount < corePoolSize，则创建并启动一个线程来执行新提交的任务
* 如果workerCount >= corePoolSize，且线程池的阻塞队列未满，则将任务添加到该阻塞队列中
* 如果workerCount >= corePoolSize && workerCount < maximumPoolSize ，并且线程池阻塞队列已满，则创建并启动一个线程来执行新提交的任务
* 如果workerCount >= maximumPoolSize，并且线程池阻塞队列已满，则根据拒绝策略来处理该任务，默认的处理方式是直接抛异常

任务调度流程如下：

![image-20210608174943039](https://gitee.com/BothSavage/PicGo/raw/master//image/image-20210608174943039.png)

> 开始提交任务，如果线程池不是在跑直接拒绝。如果在运行，判断线程池和核心数，如果还没打满核心数，直接new一个线程开始干，如果满了，那么看阻塞队列是否被打满了，如果阻塞队列还有剩余，那就送任务去排队，如果队伍也满了，看看到了线程池的极限线程数没有，如果没有到，那么new一个，如果到了直接使用拒绝策略，默认就是抛出异常
>
> 判断逻辑是：核心数，当前线程数，队列数，最大线程数，线程池状态

#### 2.3.2任务缓冲

任务缓冲模块是线程池能够管理任务的核心部分。线程池的本质是对任务和线程的管理，而做到这一点最关键的思想就是将任务和线程两者解耦，不让两者直接关联，才可以做后续的分配工作。**线程池是以生产者消费者模式**，通过一个阻塞队列来实现的。阻塞队列缓存任务，工作线程从阻塞队列中获取任务

阻塞队列支持两个附加操作

* 当队列为空，获取元素的线程会等待队列变成非空。
* 当队列为满，存储元素的线程会等待队列可用

阻塞队列常常用于生产者和消费者的场景，生产者是往队列中添加元素的线程，消费者是从队列里面拿元素的线程，阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素

![image-20210608180202008](https://gitee.com/BothSavage/PicGo/raw/master//image/image-20210608180202008.png)

使用不同的队列可以实现不一样的任务存取策略，如下成员在不同的场景下才能发挥作用

* ArrayBlockingQueue 
  * 一个使用数组实现的有界阻塞队列，此队列按照先进先出的原则对元素进行排序，支持公平锁和非公平锁
* LinkedBlockingQueue
  * 链表结构组成的有界队列，FIFO进行排序，此队列的默认长度为Integer.Max_Value，所以默认创建的该队列有容量危险
* PriorityBlockingQueue
  * 一个支持线程优先级的无界队列，默认自然顺序进行排序，也可以自定义实现compareTo方法来指定元素排序规则，不能保证同优先级元素的顺序
* DelayQueue
  * 一个实现PriorityBlockingQueue实现延迟获取的无界队列，在创建元素时候，可以指定多久才能从队列中获取当前元素，只有延时满后才能从队列中获取元素
* SynchronoQueue
  * 一个不存储元素的阻塞队列，每个put操作必须等待take操作，否则不能添加元素。支持公平锁和非公平锁，Synchron,,Queue的一个使用场景是在线程池里，这个线程池根据需要（新任务）来创建线程，如果有空闲线程则会重复使用，线程空闲了60秒会被回收
* LinkedTransferQueue
  * 一个链表结构组成的无界阻塞队列，相当于其他队列
* LinkedBlockingDeque
  * 一个由链表结构组成的双向阻塞队列，队列头部和尾部都可以添加和移除元素，多线程并发时，可以将锁的竞争最多降到一半

#### 2.3.3任务申请

由上文的任务分配部分可知，任务的执行有两种可能：一种是任务直接由新创建的线程执行。另一种是线程从任务队列中获取任务然后执行，执行完任务的空闲线程会再次去从队列中申请任务再去执行。第一种情况仅出现在线程初始创建的时候，第二种是线程获取任务绝大多数的情况。

线程需要从任务缓存模块中不断地取任务执行，帮助线程从阻塞队列中获取任务，实现线程管理模块和任务管理模块之间的通信。这部分策略由getTask方法实现，其执行流程如下图所示：

![image-20210609114541768](https://gitee.com/BothSavage/PicGo/raw/master//image/image-20210609114541768.png)

get这部分进行了多次判断，为的是控制线程的数目，为其符合线程池的状态，如果线程池现在不应该持有那么多的线程，则会返回null值，工作线程worker会不断的接受新的任务去执行，而当工作线程worker接受不到任务的时候，就会被回收

#### 2.3.4任务拒绝

任务拒绝模块是线程池的保护部分，线程池有一个最大的容量，当线程池的任务缓存队列已满，并且线程池中的线程数目达到maximumPoolSize时，就需要拒绝掉该任务，采取任务拒绝策略，保护线程池。

拒绝策略是一个接口，其设计如下：

```java
public interface RejectedExecutionHandler {
    void rejectedExecution(Runnable r, ThreadPoolExecutor executor);
}
```

用户可以通过实现这个接口取定制拒绝策略，也可以选择jdk提供的四种已有的拒绝策略，其特点如下

* ThreadPoolExecutor.AbortPolicy
  * 丢弃任务并抛出异常，这个是线程池默认的拒绝策略，在任务不能再提交的时候，抛出异常，即使反馈程序的运行状态，如果是比较关键的业务，推荐使用这个拒绝策略，这样子再系统不能承受巨大的并发量的时候，能及时通过异常状态发现
* DiscardPolicy
  * 丢弃任务，但是不抛出异常，可能使我们无法发现系统的异常状态，建议一些无关紧要的任务使用这个拒绝策略
* DiscardOldestPolicy
  * 丢弃队列最前面的任务，然后重新提交这个拒绝任务，是否使用这个拒绝策略，还要根据实际业务是否需要丢弃
* CallerRunsPolicy
  * 由调用线程（提交任务的线程）处理该任务。这种情况下需要所有的任务都执行完毕，那么就适合大量计算的任务类型去执行，多线程仅仅是作为提高吞吐量的手段，最终必须让每一个任务都执行完毕

### 2.4Woker线程管理

#### 2.4.1Worker线程

线程池为了掌握线程的状态并维护线程的生命周期，设计了线程池内的工作线程Worker。我们来看一下它的部分代码：

```java
private final class Worker extends AbstractQueuedSynchronizer implements Runnable{
    final Thread thread;//Worker持有的线程
    Runnable firstTask;//初始化的任务，可以为null
}
```

worker这个工作线程，实现了runnable接口，并持有一个Thread，一个初始化任务firstTask。thread是在调用构造方法时通过ThreadFactory来创建的线程，可以用来执行任务；firstTask用它来保存传入的第一个任务，这个任务可以有也可以为null。如果这个值是非空的，那么线程就会在启动初期去执行这个任务，也就对应核心线程创建的情况；如果为null，那么就需要创建一个线程去执行任务列表（workQueue）中的任务，也就是非核心线程的创建。

![image-20210609132315668](https://gitee.com/BothSavage/PicGo/raw/master//image/image-20210609132315668.png)

线程池需要管理线程的生命周期，需要在线程长时间不运行的时候进行回收。线程池使用一张Hash表去持有线程的引用，这样可以通过添加引用、移除引用这样的操作来控制线程的生命周期。这个时候重要的就是如何判断线程是否在运行。

> worker是通过继承AQS，使用AQS来实现独占锁这个功能。没有使用可重入锁ReentrantLock，而是使用AQS，为的就是实现不可重入的特性去反应线程现在的执行状态

* lock方法一旦获取独占锁，表示当前线程正在执行任务中
* 如果正在执行任务，则不应该中断线程
* 如果该线程现在不是独占锁的状态，也就是空闲的状态，说明没有在处理任务，这时候应该对线程进行中断
* 线程池在执行shutdown方法或tryTerminate方法时会去调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来帕努但线程池中的线程是否在空闲状态，如果线程是空闲状态那么可以进行安全的回收

在线程回收的时候就使用了这种特性，回收过程如下

![image-20210609133140680](C:\Users\y\AppData\Roaming\Typora\typora-user-images\image-20210609133140680.png)

#### 2.4.2Woker线程增加

增加线程是通过线程池中的addWorker方法，该方法的功能就是增加一个线程，该方法不考虑线程池是在哪个阶段增加的该线程，这个分配线程的策略是在上个步骤完成的，该步骤仅仅完成增加线程，并使它运行，最后返回是否成功这个结果。addWorker方法有两个参数：

firstTask、core



* firstTask参数用于指定新增的线程执行的第一个任务，该参数可以为空
* core参数为true表示新增线程时会判断当前活动线程数是否小于corePoolSize，false并表示当前活动线程数是否要小于maximumPoolSize

流程如下

![image-20210609133521842](https://gitee.com/BothSavage/PicGo/raw/master//image/image-20210609133521842.png)

> 如果线程池没有停止，就算停止了不会去new一个worker去执行剩余的任务，那么就去获取当前正在运行的线程的数目，判断core这个bool值，如果为true就去检查核心数，如果为false就去检查最大配置的线程个数，然后去登记线程，如果登记成功那么马上增加一个线程，随后就是启动流程

#### 2.4.3Worker线程回收

线程池中线程的销毁依赖JVM自动回收，线程池做的工作是根据当前线程池的状态维护一定数量的线程的引用，防止这一部分被JVM回收，当线程池决定哪些线程需要被回收的时候，只需要去消除引用就可以。Worker被创建后，就会不断的进行轮询，然后获取任务去执行，核心线程可以无限等待获取任务，非核心线程要获取限时获取任务，当woker无法获取到任务，就是获取的任务为空的时候，循环就会结束，worker会主动消除自身在线程池内引用

```java
try {
  while (task != null || (task = getTask()) != null) {
    //执行任务
  }
} finally {
  processWorkerExit(w, completedAbruptly);//获取不到任务时，主动回收自己
}
```

> 只要是线程那么就需要回收的，没有使用线程池的时候，线程就是使用完了后马上就会回收掉的，线程池的作用就是一个相当于守护线程，然会一直引用里面的工作线程，这样就会让工作线程不被回收掉，看代码里面就是给了一个死循环给工作线程，如果触发里面的退出逻辑就会执行回收工作线程

线程回收的工作是在processWorkerExit方法完成的。

![image-20210609135152574](https://gitee.com/BothSavage/PicGo/raw/master//image/image-20210609135152574.png)

事实上，在这个方法中，将线程引用移出线程池就已经结束了线程销毁的部分。但由于引起线程销毁的可能性有很多，线程池还要判断是什么引发了这次销毁，是否要改变线程池的现阶段状态，是否要根据新状态，重新分配线程。

#### 2.4.4 Worker线程执行任务

在Worker类中的run方法调用了runWorker方法来执行任务，runWorker方法的执行过程如下：

* while循环不断的通过getTask()方法来获取任务
* getTask()从阻塞队列中获取任务
* 如果线程池正在停止，那么就要保证当前线程是中断状态，否则要保证当前线程不是中断状态
* 执行任务
* 如果getTask()结果为null就跳出循环，执行processWorkerExit()，销毁线程

执行流程图如下：

![image-20210609135500818](https://gitee.com/BothSavage/PicGo/raw/master//image/image-20210609135500818.png)

> 先去申请任务，如果阻塞队列都没有任务了，直接销毁线程。如果有任务，就去申请worker的非重入锁，有锁了去判断是否线程池现在处于stop阶段，如果是的话马上停止线程，如果线程池没有关闭那么执行任务，完成任务后就释放重入锁表示线程目前就是idel状态，然后循环，最后一定会销毁线程的

## 叁：线程池在业务中的实践

### 3.1业务背景

在当今的互联网业界，为了最大程度利用**CPU的多核性能**，并行运算的能力是不可或缺的。通过**线程池管理线程获取并发性是一个非常基础的操作**，让我们来看两个典型的使用线程池获取并发性的场景。



#### 场景1：快速响应用户的请求

**描述**：用户发起的实时请求，服务追求响应时间。比如说用户要查看一个商品的信息，那么我们需要将商品维度的一系列信息如商品的价格、优惠、库存、图片等等聚合起来，展示给用户。

**分析**：从用户体验角度看，这个结果响应的越快越好，如果一个页面半天都刷不出，用户可能就放弃查看这个商品了。而面向用户的**功能聚合**通常非常复杂，伴随着**调用与调用之间的级联、多级级联**等情况，业务开发同学往往会选择使用线程池这种简单的方式，将调用封装成任务并行的执行，缩短总体响应时间。另外，使用线程池也是有考量的，这种场景最重要的就是获取最大的响应速度去满足用户，**所以应该不设置队列去缓冲并发任务**，调高corePoolSize和maxPoolSize去尽可能创造多的线程快速执行任务。

> 业务逻辑复杂，功能聚合复杂需要使用多线程，使用最大的速度去执行任务，所以不应该设置队列去缓冲并发的任务，故要提高corePoolSize和maxPoolSize。在当前正在运行的线程数小于核心数的时候会立马创建新线程去执行

![image-20210609140838651](https://gitee.com/BothSavage/PicGo/raw/master//image/image-20210609140838651.png)



#### 场景2：快速处理批量任务

